/*
    SQLToolKit/Sequence 1.0.2g
	Copyright Federico Razzoli 2012
	
	This file is part of SQLToolKit/Sequence.
	
    SQLToolKit/Sequence is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published by
    the Free Software Foundation, version 3 of the License.
	
    SQLToolKit/Sequence is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.
	
    You should have received a copy of the GNU Affero General Public License
    along with SQLToolKit/Sequence.  If not, see <http://www.gnu.org/licenses/>.
*/


/*

SQLToolKit/Sequence implementation based on:
* http://www.postgresql.org/docs/9.2/static/sql-createsequence.html
* http://www.postgresql.org/docs/9.2/static/sql-altersequence.html
* http://www.postgresql.org/docs/9.2/static/sql-dropsequence.html
* http://www.postgresql.org/docs/9.2/static/functions-sequence.html

With the following exceptions:
* SEQUENCEs are global, not at database-level
* No TEMPORARY sequences
* Can't SELECT from a SEQUENCE
* currval() and lastval() dont throw errore - if no value, return NULL
* sequence_get() and sequence_exists()
* To CREATE, ALTER and DROP, use sequence_create(), sequence_alter(), sequence_rename(), sequence_drop()
** No OWNED BY clause
** No CACHE clause
* nextval() - 3rd param is not optional
* SEQUENCE's are transactional, so new values will rollback - if no newer value has been generated by another thread in the meanwhile

Bonus:
* Added SEQUENCES information table

*/


DELIMITER ||


-- create & select db
CREATE DATABASE IF NOT EXISTS `stk_sequence`;
USE `stk_sequence`;


CREATE TABLE IF NOT EXISTS `SEQUENCES`
(
	`SEQUENCE_NAME`  CHAR(64)         NOT NULL,
	`INCREMENT`      INTEGER SIGNED   NOT NULL           COMMENT 'Default: 1',
	`MINVALUE`       BIGINT SIGNED    NOT NULL           COMMENT 'Default: 0 or -9223372036854775808',
	`MAXVALUE`       BIGINT SIGNED    NOT NULL           COMMENT 'Default: 9223372036854775808 or -1',
	`CYCLE`          BOOLEAN          NOT NULL           COMMENT 'Default: FALSE; if TRUE, value can rotate',
	`START`          BIGINT SIGNED    NOT NULL           COMMENT 'First generated value. Default: min/max',
	`CURRVAL`        BIGINT SIGNED    NULL DEFAULT NULL  COMMENT 'Current value. Default: NULL',
	`COMMENT`        CHAR(64)         NOT NULL           COMMENT 'Use this column to comment a SEQUENCE',
	
	PRIMARY KEY (`SEQUENCE_NAME`)
)
	ENGINE = InnoDB
	DEFAULT CHARACTER SET = ascii
	DEFAULT COLLATE = ascii_bin
	COMMENT = 'Internal. Contains SEQUENCEs definition & status';


DROP PROCEDURE IF EXISTS `sequence_create`;
CREATE PROCEDURE sequence_create(IN `s_name` CHAR(64),
                                 IN `s_increment` INTEGER, IN `s_minvalue` BIGINT, IN `s_maxvalue` BIGINT,
								 IN `s_cycle` BOOLEAN, IN `s_start` BIGINT,
								 IN `s_comment` CHAR(64))
	LANGUAGE SQL
	COMMENT 'Create a new sequence'
BEGIN
	-- duplicate sequence error
	DECLARE CONTINUE HANDLER
		FOR 1062
		SIGNAL SQLSTATE VALUE '45000'
			SET MESSAGE_TEXT = '[stk_sequence.sequence_create] - SEQUENCE already exists';
	
	-- set default values
	
	-- default increment
	IF `s_increment` IS NULL THEN
		SET `s_increment` = 1;
	END IF;
	
	-- default max, min, currval
	IF `s_increment` > 0 THEN
		-- ascnding
		IF `s_minvalue` IS NULL THEN
			SET `s_minvalue` = 1;
		END IF;
		IF `s_maxvalue` IS NULL THEN
			SET `s_maxvalue` = 9223372036854775807 - `s_increment`;
		END IF;
		IF `s_start` IS NULL THEN
			SET `s_start` = `s_minvalue`;
		END IF;
	ELSE
		-- descending
		IF `s_minvalue` IS NULL THEN
			SET `s_minvalue` = -9223372036854775807 - `s_increment`;
		END IF;
		IF `s_maxvalue` IS NULL THEN
			SET `s_maxvalue` = -1;
		END IF;
		IF `s_start` IS NULL THEN
			SET `s_start` = `s_maxvalue`;
		END IF;
	END IF;
	
	-- default increment
	IF `s_cycle` IS NULL THEN
		SET `s_cycle` = FALSE;
	END IF;
	
	-- create sequence
	INSERT INTO `SEQUENCES`
		SET
			`SEQUENCE_NAME`  = s_name,
			`INCREMENT`      = s_increment,
			`MINVALUE`       = s_minvalue,
			`MAXVALUE`       = s_maxvalue,
			`CYCLE`          = s_cycle,
			`START`          = s_start,
			`COMMENT`        = s_comment;
END;


DROP PROCEDURE IF EXISTS `sequence_alter`;
CREATE PROCEDURE sequence_alter(IN `s_name` CHAR(64),
                                IN `s_increment` INTEGER, IN `s_minvalue` BIGINT, IN `s_maxvalue` BIGINT,
								IN `s_cycle` BOOLEAN,
								IN `s_comment` CHAR(64))
	LANGUAGE SQL
	COMMENT 'Create a new sequence'
BEGIN
	-- UPDATE SET clause
	DECLARE set_clause    TEXT  DEFAULT '';
	-- UPDATE SET clause has begun
	DECLARE set_is_empty  BOOL  DEFAULT TRUE;
	-- backup @__stk_sql in case it exists
	DECLARE tmp_val       TEXT  DEFAULT NULL;
	
	-- duplicate sequence error
	DECLARE CONTINUE HANDLER
		FOR 1062
		SIGNAL SQLSTATE VALUE '45000'
			SET MESSAGE_TEXT = '[stk_sequence.sequence_alter] - SEQUENCE already exists';
	
	-- set default values
	
	-- default increment
	IF `s_increment` IS NOT NULL THEN
		-- add pair
		SET set_clause = CONCAT(set_clause, '`INCREMENT` = ', s_increment);
		SET set_is_empty = FALSE;
	END IF;
	
	-- default minvalue
	IF `s_minvalue` IS NOT NULL THEN
		-- add separator
		IF set_is_empty IS NOT TRUE THEN
			SET set_clause = CONCAT(set_clause, ', ');
		END IF;
		-- add pair
		SET set_clause = CONCAT(set_clause, '`MINVALUE` = ', s_minvalue);
		SET set_is_empty = FALSE;
	END IF;
	
	-- default maxvalue
	IF `s_maxvalue` IS NOT NULL THEN
		-- add separator
		IF set_is_empty IS NOT TRUE THEN
			SET set_clause = CONCAT(set_clause, ', ');
		END IF;
		-- add pair
		SET set_clause = CONCAT(set_clause, '`MAXVALUE` = ', s_maxvalue);
		SET set_is_empty = FALSE;
	END IF;
	
	-- default cycle
	IF `s_cycle` IS NOT NULL THEN
		-- add separator
		IF set_is_empty IS NOT TRUE THEN
			SET set_clause = CONCAT(set_clause, ', ');
		END IF;
		-- add pair
		SET set_clause = CONCAT(set_clause, '`CYCLE` = ', s_cycle);
		SET set_is_empty = FALSE;
	END IF;
	
	-- default comment
	IF `s_comment` IS NOT NULL THEN
		-- add separator
		IF set_is_empty IS NOT TRUE THEN
			SET set_clause = CONCAT(set_clause, ', ');
		END IF;
		-- add pair
		SET set_clause = CONCAT(set_clause, '`COMMENT` = ''', s_comment, '''');
		SET set_is_empty = FALSE;
	END IF;
	
	-- alter sequence
	IF set_is_empty IS NOT TRUE THEN
		SET tmp_val = @__stk_sql;
		-- compose statement
		SET @__stk_sql = CONCAT(
			'UPDATE `stk_sequence`.`SEQUENCES` ',
				'SET ', set_clause, ' ',
				'WHERE `SEQUENCE_NAME` = ''', s_name, ''';'
		);
		PREPARE __stk_stmt_eval FROM @__stk_sql;
		SET @__stk_sql = tmp_val;
		SET tmp_val = NULL;
		EXECUTE __stk_stmt_eval;
		DEALLOCATE PREPARE __stk_stmt_eval;
	END IF;
END;


DROP PROCEDURE IF EXISTS `sequence_get`;
CREATE PROCEDURE sequence_get(IN `s_name` CHAR(64),
                              OUT `s_increment` INTEGER, OUT `s_minvalue` BIGINT, OUT `s_maxvalue` BIGINT,
							  OUT `s_cycle` BOOLEAN, OUT `s_comment` CHAR(64))
	LANGUAGE SQL
	COMMENT 'Get info about a SEQUENCE'
BEGIN
	DECLARE CONTINUE HANDLER
		FOR NOT FOUND
		SIGNAL SQLSTATE VALUE '45000'
			SET MESSAGE_TEXT = '[stk_sequence.sequence_get] - SEQUENCE does not exists';
	
	SELECT
		       `INCREMENT`, `MINVALUE`, `MAXVALUE`, `CYCLE`, `COMMENT`
		FROM   `stk_sequence`.`SEQUENCES`
		WHERE  `SEQUENCE_NAME` = s_name
		INTO   `s_increment`, `s_minvalue`, `s_maxvalue`, `s_cycle`, `s_comment`;
END;


DROP FUNCTION IF EXISTS `sequence_exists`;
CREATE FUNCTION sequence_exists(`s_name` CHAR(64))
	RETURNS BOOL
	NOT DETERMINISTIC
	LANGUAGE SQL
	COMMENT 'Return TRUE if SEQUENCE exists, else FALSE'
BEGIN
	RETURN (
		SELECT EXISTS (
			SELECT 1
				FROM   `stk_sequence`.`SEQUENCES`
				WHERE  `SEQUENCE_NAME` = s_name
		)
	);
END;


DROP PROCEDURE IF EXISTS `sequence_drop`;
CREATE PROCEDURE sequence_drop(IN `s_name` CHAR(64))
	LANGUAGE SQL
	COMMENT 'Drop sequence if exists'
BEGIN
	DELETE FROM `SEQUENCES` WHERE `SEQUENCE_NAME` = s_name;
END;


DROP PROCEDURE IF EXISTS `sequence_rename`;
CREATE PROCEDURE sequence_rename(IN `s_old_name` CHAR(64), IN `s_new_name` CHAR(64))
	LANGUAGE SQL
	COMMENT 'Rename sequence if exists'
BEGIN
	-- duplicate sequence error
	DECLARE CONTINUE HANDLER
		FOR 1062
		SIGNAL SQLSTATE VALUE '45000'
			SET MESSAGE_TEXT = '[stk_sequence.sequence_rename] - SEQUENCE already exists';
	
	UPDATE     `stk_sequence`.`SEQUENCES`
		SET    `SEQUENCE_NAME` = s_new_name
		WHERE  `SEQUENCE_NAME` = s_old_name;
END;


DROP PROCEDURE IF EXISTS `log_value`;
CREATE PROCEDURE `log_value`(IN `s_name` CHAR(64), IN `val` BIGINT SIGNED)
	LANGUAGE SQL
	COMMENT 'Internal. Log last generated value'
BEGIN
	-- session log table may not exist
	CREATE TEMPORARY TABLE IF NOT EXISTS `stk_sequence`.`sequence_session_log`
	(
		`timestamp`      TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP
		                                               NOT NULL COMMENT 'Value generation timestamp',
		`sequence_name`  CHAR(64) CHARACTER SET ascii  NOT NULL COMMENT 'SEQUENCE from which the value was read',
		`value`          BIGINT UNSIGNED               NOT NULL COMMENT 'Value that was read',
		PRIMARY KEY (`sequence_name`)
	)
		ENGINE      = MEMORY
		COMMENT     = 'Logs values read by this session, they can be re-read'
		ROW_FORMAT  = FIXED
		MIN_ROWS    = 1;
	
	-- new value replaces old
	REPLACE INTO `stk_sequence`.`sequence_session_log`
			(`sequence_name`, `value`)
		VALUES
			(s_name, val);
END;


-- Set new value for the sequence, if it exists.
-- Does not validate the value.
-- If is_called is FALSE, when nextval() is called, the value will advance before returning.
DROP FUNCTION IF EXISTS `setval`;
CREATE FUNCTION setval(`s_name` CHAR(64), `new_value` BIGINT SIGNED, `is_called` BOOL)
	RETURNS BIGINT SIGNED
	DETERMINISTIC
	MODIFIES SQL DATA
	LANGUAGE SQL
	COMMENT 'Change current value for a sequence and returns it'
BEGIN
	IF (s_name + new_value + is_called) IS NULL THEN
		SIGNAL SQLSTATE VALUE '45000' SET
			MESSAGE_TEXT  = '[stk_sequence.setval] At least one argument is NULL';
	END IF;
	
	IF is_called IS NOT TRUE THEN
		-- set currval to NULL & update start;
		-- next generated value will be start
		UPDATE
				   `stk_sequence`.`SEQUENCES`
			SET
			       `CURRVAL`        = NULL,
				   `START`          = new_value
			WHERE  `SEQUENCE_NAME`  = s_name;
	ELSE
		-- update SEQUENCE
		UPDATE
				   `stk_sequence`.`SEQUENCES`
			SET    `CURRVAL`        = new_value
			WHERE  `SEQUENCE_NAME`  = s_name;
		
		-- log generated value as if it was called
		CALL `stk_sequence`.`log_value`(s_name, new_value);
	END IF;
	
	-- for compatibility with PostgreSQL
	RETURN new_value;
END;


DROP FUNCTION IF EXISTS `nextval`;
CREATE FUNCTION `nextval`(`s_name` CHAR(64))
	RETURNS BIGINT SIGNED
	NOT DETERMINISTIC
	LANGUAGE SQL
	COMMENT 'Advance a sequence and return new value'
BEGIN
	-- can rotate?
	DECLARE rotate    BIGINT SIGNED;
	-- start value
	DECLARE v_start   BIGINT SIGNED;
	-- increment
	DECLARE v_inc     BIGINT SIGNED;
	-- minvalue
	DECLARE v_min     BIGINT SIGNED;
	-- maxvalue
	DECLARE v_max     BIGINT SIGNED;
	-- currval
	DECLARE v_cur     BIGINT SIGNED;
	-- output
	DECLARE next_val  BIGINT SIGNED;
	
	-- bound & direction
	DECLARE v_begin   BIGINT SIGNED;
	DECLARE v_end     BIGINT SIGNED;
	DECLARE v_sign    TINYINT SIGNED;
	
	-- get & lock sequence status
	SELECT
			   `INCREMENT`, `MINVALUE`, `MAXVALUE`, `CURRVAL`, `CYCLE`, `START`
		FROM   `stk_sequence`.`SEQUENCES`
		WHERE  `SEQUENCE_NAME` = s_name
		INTO   `v_inc`, `v_min`, `v_max`, `v_cur`, `rotate`, `v_start`
		FOR UPDATE;
	
	IF v_cur IS NULL THEN
		-- first value
		SET next_val = v_start;
	ELSE
		-- increment value
		SET next_val = v_cur + v_inc;
		
		-- set bounds
		IF v_inc > 0 THEN
			SET v_begin  = v_min;
			SET v_end    = v_max;
			SET v_sign   = +1;
		ELSE
			SET v_begin  = v_max;
			SET v_end    = v_min;
			SET v_sign   = -1;
		END IF;
		
		-- out of range?
		IF next_val NOT BETWEEN v_min AND v_max THEN
			IF rotate IS NOT TRUE THEN
				-- can't rotate: throw error
				SIGNAL SQLSTATE VALUE '45000'
					SET MESSAGE_TEXT = '[stk_sequence.nextval] - SEQUENCE reached minvalue or maxvalue';
			ELSE
				-- rotate
				SET next_val = v_begin + ((next_val - v_end) /* * v_sign */ ) - v_sign;
			END IF;
		END IF;
	END IF;
	
	-- update sequence
	UPDATE
			   `stk_sequence`.`SEQUENCES`
		SET    `CURRVAL`        = next_val
		WHERE  `SEQUENCE_NAME`  = s_name;
	
	-- log result at session level
	CALL `stk_sequence`.`log_value`(s_name, next_val);
	
	RETURN next_val;
END;


DROP FUNCTION IF EXISTS `currval`;
CREATE FUNCTION `currval`(`s_name` CHAR(64))
	RETURNS BIGINT SIGNED
	LANGUAGE SQL
	NOT DETERMINISTIC
	READS SQL DATA
	COMMENT 'Return last value generated by given SEQUENCE for this session, or NULL'
BEGIN
	DECLARE res BIGINT SIGNED;
	
	-- SQLEXCEPTION = table not exist, nextval() never called;
	-- NOT FOUND: record not exist, never called for that SEQUENCE
	-- so, return NULL
	DECLARE CONTINUE HANDLER
		FOR NOT FOUND, 1146
		RETURN NULL;
	
	-- last called value should be logged in this table
	RETURN (
			SELECT
					`value`
				FROM `stk_sequence`.`sequence_session_log`
				WHERE `sequence_name` = s_name
		);
END;


DROP FUNCTION IF EXISTS `lastval`;
CREATE FUNCTION `lastval`()
	RETURNS BIGINT SIGNED
	LANGUAGE SQL
	NOT DETERMINISTIC
	READS SQL DATA
	COMMENT 'Return last value generated any SEQUENCE for this session, or NULL'
BEGIN
	DECLARE res BIGINT SIGNED;
	
	-- SQLEXCEPTION = table not exist, nextval() never called;
	-- NOT FOUND: record not exist, never called for that SEQUENCE
	-- so, return NULL
	DECLARE CONTINUE HANDLER
		FOR NOT FOUND, 1146
		RETURN NULL;
	
	-- last called value should be logged in this table
	RETURN (
			SELECT
					      `value`
				FROM      `stk_sequence`.`sequence_session_log`
				ORDER BY  `timestamp` DESC
				LIMIT     1
		);
END;


DROP FUNCTION IF EXISTS `get_version`;
CREATE FUNCTION `get_version`()
	RETURNS CHAR(40)
	LANGUAGE SQL
	DETERMINISTIC
	NO SQL
	COMMENT 'Return version info'
BEGIN
	RETURN 'STK/Sequence 1.0.2g';
END;


||

DELIMITER ;
